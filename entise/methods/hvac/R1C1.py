import logging

import numpy as np
import pandas as pd

from entise.constants import SEP, Types
from entise.constants import Columns as C
from entise.constants import Constants as Const
from entise.constants import Objects as O
from entise.core.base import Method
from entise.methods.auxiliary.internal.selector import InternalGains
from entise.methods.auxiliary.solar.selector import SolarGains
from entise.methods.auxiliary.ventilation.selector import Ventilation
from entise.methods.hvac.defaults import (
    DEFAULT_ACTIVE_COOLING,
    DEFAULT_ACTIVE_HEATING,
    DEFAULT_POWER_COOLING,
    DEFAULT_POWER_HEATING,
    DEFAULT_TEMP_INIT,
    DEFAULT_TEMP_MAX,
    DEFAULT_TEMP_MIN,
    DEFAULT_VENTILATION,
)

logger = logging.getLogger(__name__)

# Module-level caches (per process)
_WEATHER_CACHE: dict[tuple, pd.DataFrame] = {}


class R1C1(Method):
    """Implements the 1R1C model for HVAC demand and indoor temperature simulation.

    The 1R1C model calculates time-series data for indoor temperature and energy
    demand for heating and cooling based on provided inputs such as weather data,
    resistance, and capacitance properties. It also summarizes total heating and
    cooling demands over the simulation period. This model is typically used for
    building energy performance analysis and HVAC load calculations.

    Attributes:
        types (list): A list of applicable types for the method. In this case, it
            includes only Types.HVAC.
        name (str): The name of the model.
        required_keys (list): Keys required in the input data for the model to
            execute, such as capacitance, resistance, and weather data.
        optional_keys (list): Additional keys that are not mandatory but may be
            included in the input data, such as power heating, power cooling,
            or ventilation settings.
        required_timeseries (list): Time-series data required to compute the
            outputs, such as weather data.
        optional_timeseries (list): Optional time-series data inputs, such as
            internal and solar gains.
        output_summary (dict): Summary of the output results, providing keys with
            their descriptions, such as total heating and cooling demands.
        output_timeseries (dict): Time-series output data generated by the model,
            including indoor temperature, heating load, and cooling load.
    """

    types = [Types.HVAC]
    name = "1R1C"
    required_keys = [O.CAPACITANCE, O.RESISTANCE, O.WEATHER]
    optional_keys = [
        O.POWER_HEATING,
        O.POWER_COOLING,
        O.ACTIVE_HEATING,
        O.ACTIVE_COOLING,
        O.TEMP_INIT,
        O.TEMP_MIN,
        O.TEMP_MAX,
        O.AREA,
    ]
    required_timeseries = [O.WEATHER]
    optional_timeseries = [O.GAINS_INTERNAL, O.GAINS_SOLAR, O.VENTILATION]
    output_summary = {
        f"{C.DEMAND}_{Types.HEATING}": "total heating demand",
        f"{C.DEMAND}_{Types.COOLING}": "total cooling demand",
    }
    output_timeseries = {
        f"{C.TEMP_IN}": "indoor temperature",
        f"{C.LOAD}_{Types.HEATING}": "heating load",
        f"{C.LOAD}_{Types.COOLING}": "cooling load",
    }

    def generate(
        self,
        obj: dict = None,
        data: dict = None,
        ts_type: str = Types.HVAC,
        *,
        capacitance: float = None,
        resistance: float = None,
        weather: pd.DataFrame = None,
        power_heating: float = None,
        power_cooling: float = None,
        active_heating: bool = None,
        active_cooling: bool = None,
        ventilation: float = None,
        temp_init: float = None,
        temp_min: float = None,
        temp_max: float = None,
        gains_internal: pd.DataFrame = None,
        gains_solar: pd.DataFrame = None,
        area: float = None,
        height: float = None,
    ):
        """Generate HVAC time series based on input parameters and weather data.

        This method implements the abstract generate method from the Method base class.
        It processes the input parameters, calculates the indoor temperature and energy
        demand time series, and returns both the time series and summary statistics.

        Args:
            obj (dict, optional): Dictionary containing building parameters. Defaults to None.
            data (dict, optional): Dictionary containing input data. Defaults to None.
            ts_type (str, optional): Time series type to generate. Defaults to Types.HVAC.
            capacitance (float, optional): Thermal capacitance in J/K. Defaults to None.
            resistance (float, optional): Thermal resistance in K/W. Defaults to None.
            weather (pd.DataFrame, optional): Weather data with outdoor temperature. Defaults to None.
            power_heating (float, optional): Maximum heating power in W. Defaults to None.
            power_cooling (float, optional): Maximum cooling power in W. Defaults to None.
            active_heating (bool, optional): Whether heating is active. Defaults to None.
            active_cooling (bool, optional): Whether cooling is active. Defaults to None.
            ventilation (float, optional): Ventilation rate in W/K. Defaults to None.
            temp_init (float, optional): Initial indoor temperature in °C. Defaults to None.
            temp_min (float, optional): Minimum indoor temperature in °C. Defaults to None.
            temp_max (float, optional): Maximum indoor temperature in °C. Defaults to None.
            gains_internal (pd.DataFrame, optional): Internal heat gains in W. Defaults to None.
            gains_solar (pd.DataFrame, optional): Solar heat gains in W. Defaults to None.
            area (float, optional): Heated area in m². Defaults to None.
            height (float, optional): Heated height in m³. Defaults to None.

        Returns:
            dict: Dictionary containing:
                - "summary" (dict): Summary statistics including total heating and
                  cooling demand, and maximum heating and cooling loads.
                - "timeseries" (pd.DataFrame): Time series of indoor temperature,
                  heating load, and cooling load with timestamps as index.

        Raises:
            Exception: If required data is missing or invalid.
        """
        # Process keyword arguments
        processed_obj, processed_data = self._process_kwargs(
            obj,
            data,
            capacitance=capacitance,
            resistance=resistance,
            weather=weather,
            power_heating=power_heating,
            power_cooling=power_cooling,
            active_heating=active_heating,
            active_cooling=active_cooling,
            ventilation=ventilation,
            temp_init=temp_init,
            temp_min=temp_min,
            temp_max=temp_max,
            gains_internal=gains_internal,
            gains_solar=gains_solar,
            area=area,
            height=height,
        )

        # Get input data
        processed_obj, processed_data = self._get_input_data(processed_obj, processed_data, ts_type)

        # Timestep in seconds (assuming a regular time grid)
        idx = processed_data[O.WEATHER][C.DATETIME].values.astype("datetime64[ns]")
        timestep = np.float32((idx[1] - idx[0]) / np.timedelta64(1, "s"))

        # Precompute auxiliary data
        processed_data[O.GAINS_SOLAR] = SolarGains().generate(processed_obj, processed_data)
        processed_data[O.GAINS_INTERNAL] = InternalGains().generate(processed_obj, processed_data)
        processed_data[O.VENTILATION] = Ventilation().generate(processed_obj, processed_data)

        # Compute temperature and energy demand
        temp_in, p_heat, p_cool = calculate_timeseries(processed_obj, processed_data, timestep)

        logger.debug(f"[HVAC R1C1] {ts_type}: max heating {p_heat.max()}, cooling {p_cool.max()}")

        return self._format_output(temp_in, p_heat, p_cool, processed_data, timestep)

    def _get_input_data(self, obj: dict, data: dict, method_type: str = Types.HVAC) -> tuple[dict, dict]:
        """Process and validate input data for HVAC calculation.

        This function extracts required and optional parameters from the input dictionaries,
        applies default values where needed, performs data validation, and prepares the
        data for HVAC calculation.

        Args:
            obj (dict): Dictionary containing building parameters such as thermal properties
                and temperature setpoints.
            data (dict): Dictionary containing input data such as weather information.
            method_type (str, optional): Method type to use for prefixing. Defaults to Types.HVAC.

        Returns:
            tuple: A tuple containing:
                - obj_out (dict): Processed object parameters with defaults applied.
                - data_out (dict): Processed data with required format for calculation.

        Notes:
            - Parameters can be specified with method-specific prefixes (e.g., "hvac:temp_min")
              which will take precedence over generic parameters (e.g., "temp_min").
        """
        obj_out = {
            O.ID: Method.get_with_backup(obj, O.ID),
            O.ACTIVE_COOLING: Method.get_with_method_backup(obj, O.ACTIVE_COOLING, method_type, DEFAULT_ACTIVE_COOLING),
            O.ACTIVE_HEATING: Method.get_with_method_backup(obj, O.ACTIVE_HEATING, method_type, DEFAULT_ACTIVE_HEATING),
            O.AREA: Method.get_with_method_backup(obj, O.AREA, method_type, Const.DEFAULT_AREA.value),
            O.GAINS_INTERNAL: Method.get_with_method_backup(obj, O.GAINS_INTERNAL, method_type),
            O.GAINS_INTERNAL_COL: Method.get_with_method_backup(obj, O.GAINS_INTERNAL_COL, method_type),
            O.GAINS_SOLAR: Method.get_with_method_backup(obj, O.GAINS_SOLAR, method_type),
            O.HEIGHT: Method.get_with_method_backup(obj, O.HEIGHT, method_type, Const.DEFAULT_HEIGHT.value),
            O.LAT: Method.get_with_method_backup(obj, O.LAT, method_type),
            O.LON: Method.get_with_method_backup(obj, O.LON, method_type),
            O.POWER_COOLING: Method.get_with_method_backup(obj, O.POWER_COOLING, method_type, DEFAULT_POWER_COOLING),
            O.POWER_HEATING: Method.get_with_method_backup(obj, O.POWER_HEATING, method_type, DEFAULT_POWER_HEATING),
            O.RESISTANCE: Method.get_with_method_backup(obj, O.RESISTANCE, method_type),
            O.CAPACITANCE: Method.get_with_method_backup(obj, O.CAPACITANCE, method_type),
            O.TEMP_INIT: Method.get_with_method_backup(obj, O.TEMP_INIT, method_type, DEFAULT_TEMP_INIT),
            O.TEMP_MAX: Method.get_with_method_backup(obj, O.TEMP_MAX, method_type, DEFAULT_TEMP_MAX),
            O.TEMP_MIN: Method.get_with_method_backup(obj, O.TEMP_MIN, method_type, DEFAULT_TEMP_MIN),
            O.VENTILATION: Method.get_with_method_backup(obj, O.VENTILATION, method_type, DEFAULT_VENTILATION),
            O.VENTILATION_COL: Method.get_with_method_backup(obj, O.VENTILATION_COL, method_type),
        }
        weather_key = Method.get_with_method_backup(obj, O.WEATHER, method_type, O.WEATHER)
        weather = Method.get_with_backup(data, weather_key)
        windows_key = Method.get_with_method_backup(obj, O.WINDOWS, method_type)
        windows = Method.get_with_backup(data, windows_key) if isinstance(windows_key, str) else None
        internal_key = Method.get_with_method_backup(obj, O.GAINS_INTERNAL, method_type)
        internal_gains = Method.get_with_backup(data, internal_key) if isinstance(internal_key, str) else None
        ventilation_key = Method.get_with_method_backup(obj, O.VENTILATION, method_type)
        ventilation = Method.get_with_backup(data, ventilation_key) if isinstance(ventilation_key, str) else None
        data_out = {
            O.WEATHER: weather,
            O.WINDOWS: windows,
            internal_key: internal_gains,
            ventilation_key: ventilation,
        }

        # Clean up
        obj_out = {k: v for k, v in obj_out.items() if v is not None}
        data_out = {k: v for k, v in data_out.items() if v is not None}

        # Safe datetime handling
        weather_cache_key = weather_key
        weather_cached = _WEATHER_CACHE.get(weather_cache_key)
        if weather_cached is None:
            if O.WEATHER in data_out:
                weather = data_out[O.WEATHER].copy()
                weather = self._strip_weather_height(weather)
                weather[C.DATETIME] = pd.to_datetime(weather[C.DATETIME])
                weather.set_index(C.DATETIME, inplace=True, drop=False)
                data_out[O.WEATHER] = weather
                _WEATHER_CACHE[weather_cache_key] = weather
        else:
            data_out[O.WEATHER] = weather_cached

        return obj_out, data_out

    @staticmethod
    def _format_output(temp_in, p_heat, p_cool, data, timestep) -> dict:
        summary = {
            f"{Types.HEATING}{SEP}{C.DEMAND}[Wh]": int(round(p_heat.sum() * timestep / 3600)),
            f"{Types.HEATING}{SEP}{O.LOAD_MAX}[W]": int(max(p_heat)),
            f"{Types.COOLING}{SEP}{C.DEMAND}[Wh]": int(round(p_cool.sum() * timestep / 3600)),
            f"{Types.COOLING}{SEP}{O.LOAD_MAX}[W]": int(max(p_cool)),
        }

        df = pd.DataFrame(
            {
                f"{C.TEMP_IN}": temp_in,
                f"{Types.HEATING}{SEP}{C.LOAD}[W]": p_heat,
                f"{Types.COOLING}{SEP}{C.LOAD}[W]": p_cool,
            },
            index=data[O.WEATHER].index,
        )
        df.index.name = C.DATETIME

        return {"summary": summary, "timeseries": df}


def calculate_timeseries(obj: dict, data: dict, timestep: float) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Calculate HVAC time series using a 1R1C model.

    This function simulates the thermal behavior of a building using a simple
    one-resistance, one-capacitance (1R1C) model. It calculates the indoor temperature
    and the heating and cooling power required to maintain comfort conditions.

    Args:
        obj (dict): A dictionary containing building parameters such as thermal
            resistance, capacitance, initial temperature, temperature limits, and
            heating/cooling capabilities.
        data (dict): A dictionary containing time-series data such as weather
            information, solar gains, internal gains, and ventilation rates.
        timestep (float): The time step in seconds for the simulation.

    Returns:
        tuple: A tuple containing:
            - temp_in (np.ndarray): Array of indoor temperatures over time.
            - p_heat (np.ndarray): Array of heating power over time.
            - p_cool (np.ndarray): Array of cooling power over time.

    Notes:
        - The function simulates the building's thermal behavior time step by time step
        - At each time step, it calculates the net heat transfer, the required heating
          and cooling power, and the resulting indoor temperature
        - The simulation accounts for thermal inertia, heat gains, and heat losses
        - The function uses NumPy for efficient numerical computations and is trimmed for speed
    """
    # Get objects
    thermal_resistance = np.float32(obj[O.RESISTANCE])
    thermal_capacitance = np.float32(obj[O.CAPACITANCE])
    temp_init = np.float32(obj[O.TEMP_INIT])
    temp_min = np.float32(obj[O.TEMP_MIN])
    temp_max = np.float32(obj[O.TEMP_MAX])
    active_heat = bool(obj[O.ACTIVE_HEATING])
    active_cool = bool(obj[O.ACTIVE_COOLING])
    power_heat_max = np.float32(obj[O.POWER_HEATING])
    power_cool_max = np.float32(obj[O.POWER_COOLING])

    # Get data
    weather = data[O.WEATHER]
    temp_air = weather[C.TEMP_AIR].to_numpy(dtype=np.float32, copy=False)
    solar_gains = data[O.GAINS_SOLAR].to_numpy(dtype=np.float32, copy=False).ravel()
    internal_gains = data[O.GAINS_INTERNAL].to_numpy(dtype=np.float32, copy=False).ravel()
    ventilation = data[O.VENTILATION].to_numpy(dtype=np.float32, copy=False).ravel()

    n_steps = temp_air.shape[0]
    temp_in = np.empty(n_steps, dtype=np.float32)
    p_heat = np.zeros(n_steps, dtype=np.float32)
    p_cool = np.zeros(n_steps, dtype=np.float32)

    temp_in[0] = temp_init

    # Precompute invariants for the inner loop (these reduce the number of divisions to speed up calculations)
    inv_resistance = np.float32(1.0) / thermal_resistance
    inv_timestep = np.float32(1.0) / timestep
    timestep_over_cap = timestep / thermal_capacitance

    # Loop state
    temp_prev = temp_in[0]

    for t in range(1, n_steps):
        # Passive heat transfer and gains
        net_transfer = calc_net_heat_transfer(
            temp_air[t], temp_prev, solar_gains[t], internal_gains[t], ventilation[t], inv_resistance
        )

        # Heating power
        p_heat[t] = calc_heating_power(
            temp_prev, temp_min, thermal_capacitance, inv_timestep, net_transfer, power_heat_max, active_heat
        )

        # Cooling power
        p_cool[t] = calc_cooling_power(
            temp_prev, temp_max, thermal_capacitance, inv_timestep, net_transfer, power_cool_max, active_cool
        )

        # Indoor temperature
        temp_prev = calc_temp_in(temp_prev, net_transfer, p_heat[t], p_cool[t], timestep_over_cap)
        temp_in[t] = temp_prev

    return temp_in, p_heat, p_cool


def calc_net_heat_transfer(
    temp_air: float,
    temp_prev: float,
    solar_gains: float,
    internal_gains: float,
    ventilation: float,
    inv_resistance: float,
) -> float:
    """Calculate net heat transfer for a building zone."""
    delta_temp = temp_air - temp_prev
    conduction_loss = delta_temp * inv_resistance
    ventilation_loss = ventilation * delta_temp
    return conduction_loss + ventilation_loss + solar_gains + internal_gains


def calc_heating_power(
    temp_prev: float,
    temp_min: float,
    thermal_capacitance: float,
    inv_timestep: float,
    net_transfer: float,
    power_heat_max: float,
    active: bool,
) -> float:
    """Calculate required heating power for a building zone."""
    if not active:
        return 0

    required_heating_power = thermal_capacitance * (temp_min - temp_prev) * inv_timestep - net_transfer

    if required_heating_power > 0:
        return min(required_heating_power, power_heat_max)

    return 0


def calc_cooling_power(
    temp_prev: float,
    temp_max: float,
    thermal_capacitance: float,
    inv_timestep: float,
    net_transfer: float,
    power_cool_max: float,
    active: bool,
) -> float:
    """Calculate required cooling power for a building zone."""
    if not active:
        return 0

    required_cooling_power = thermal_capacitance * (temp_prev - temp_max) * inv_timestep + net_transfer

    if required_cooling_power > 0:
        return min(required_cooling_power, power_cool_max)

    return 0


def calc_temp_in(
    temp_prev: float, net_transfer: float, power_heat: float, power_cool: float, timestep_over_cap: float
) -> float:
    """Calculate indoor temperature for the next time step."""
    return temp_prev + timestep_over_cap * (net_transfer + power_heat - power_cool)
