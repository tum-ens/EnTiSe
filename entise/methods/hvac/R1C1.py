import logging

import numpy as np
import pandas as pd

from entise.constants import SEP, Types
from entise.constants import Columns as C
from entise.constants import Constants as Const
from entise.constants import Objects as O
from entise.core.base import Method
from entise.methods.auxiliary.internal.selector import InternalGains
from entise.methods.auxiliary.solar.selector import SolarGains
from entise.methods.auxiliary.ventilation.selector import Ventilation
from entise.methods.hvac.defaults import (
    DEFAULT_ACTIVE_COOLING,
    DEFAULT_ACTIVE_HEATING,
    DEFAULT_POWER_COOLING,
    DEFAULT_POWER_HEATING,
    DEFAULT_TEMP_INIT,
    DEFAULT_TEMP_MAX,
    DEFAULT_TEMP_MIN,
    DEFAULT_VENTILATION,
)

logger = logging.getLogger(__name__)


class R1C1(Method):
    """Implements the R1C1 model for HVAC demand and indoor temperature simulation.

    The R1C1 model calculates time-series data for indoor temperature and energy
    demand for heating and cooling based on provided inputs such as weather data,
    resistance, and capacitance properties. It also summarizes total heating and
    cooling demands over the simulation period. This model is typically used for
    building energy performance analysis and HVAC load calculations.

    Attributes:
        types (list): A list of applicable types for the method. In this case, it
            includes only Types.HVAC.
        name (str): The name of the model.
        required_keys (list): Keys required in the input data for the model to
            execute, such as capacitance, resistance, and weather data.
        optional_keys (list): Additional keys that are not mandatory but may be
            included in the input data, such as power heating, power cooling,
            or ventilation settings.
        required_timeseries (list): Time-series data required to compute the
            outputs, such as weather data.
        optional_timeseries (list): Optional time-series data inputs, such as
            internal and solar gains.
        output_summary (dict): Summary of the output results, providing keys with
            their descriptions, such as total heating and cooling demands.
        output_timeseries (dict): Time-series output data generated by the model,
            including indoor temperature, heating load, and cooling load.
    """

    types = [Types.HVAC]
    name = "1R1C"
    required_keys = [O.CAPACITANCE, O.RESISTANCE, O.WEATHER]
    optional_keys = [
        O.POWER_HEATING,
        O.POWER_COOLING,
        O.ACTIVE_HEATING,
        O.ACTIVE_COOLING,
        O.TEMP_INIT,
        O.TEMP_MIN,
        O.TEMP_MAX,
        O.AREA,
    ]
    required_timeseries = [O.WEATHER]
    optional_timeseries = [O.GAINS_INTERNAL, O.GAINS_SOLAR, O.VENTILATION]
    output_summary = {
        f"{C.DEMAND}_{Types.HEATING}": "total heating demand",
        f"{C.DEMAND}_{Types.COOLING}": "total cooling demand",
    }
    output_timeseries = {
        f"{C.TEMP_IN}": "indoor temperature",
        f"{C.LOAD}_{Types.HEATING}": "heating load",
        f"{C.LOAD}_{Types.COOLING}": "cooling load",
    }

    def generate(
        self,
        obj: dict = None,
        data: dict = None,
        ts_type: str = Types.HVAC,
        *,
        capacitance: float = None,
        resistance: float = None,
        weather: pd.DataFrame = None,
        power_heating: float = None,
        power_cooling: float = None,
        active_heating: bool = None,
        active_cooling: bool = None,
        ventilation: float = None,
        temp_init: float = None,
        temp_min: float = None,
        temp_max: float = None,
        gains_internal: pd.DataFrame = None,
        gains_solar: pd.DataFrame = None,
        area: float = None,
        height: float = None,
    ):
        """Generate HVAC time series based on input parameters and weather data.

        This method implements the abstract generate method from the Method base class.
        It processes the input parameters, calculates the indoor temperature and energy
        demand time series, and returns both the time series and summary statistics.

        Args:
            obj (dict, optional): Dictionary containing building parameters. Defaults to None.
            data (dict, optional): Dictionary containing input data. Defaults to None.
            ts_type (str, optional): Time series type to generate. Defaults to Types.HVAC.
            capacitance (float, optional): Thermal capacitance in J/K. Defaults to None.
            resistance (float, optional): Thermal resistance in K/W. Defaults to None.
            weather (pd.DataFrame, optional): Weather data with outdoor temperature. Defaults to None.
            power_heating (float, optional): Maximum heating power in W. Defaults to None.
            power_cooling (float, optional): Maximum cooling power in W. Defaults to None.
            active_heating (bool, optional): Whether heating is active. Defaults to None.
            active_cooling (bool, optional): Whether cooling is active. Defaults to None.
            ventilation (float, optional): Ventilation rate in W/K. Defaults to None.
            temp_init (float, optional): Initial indoor temperature in °C. Defaults to None.
            temp_min (float, optional): Minimum indoor temperature in °C. Defaults to None.
            temp_max (float, optional): Maximum indoor temperature in °C. Defaults to None.
            gains_internal (pd.DataFrame, optional): Internal heat gains in W. Defaults to None.
            gains_solar (pd.DataFrame, optional): Solar heat gains in W. Defaults to None.
            area (float, optional): Heated area in m². Defaults to None.
            height (float, optional): Heated height in m³. Defaults to None.

        Returns:
            dict: Dictionary containing:
                - "summary" (dict): Summary statistics including total heating and
                  cooling demand, and maximum heating and cooling loads.
                - "timeseries" (pd.DataFrame): Time series of indoor temperature,
                  heating load, and cooling load with timestamps as index.

        Raises:
            Exception: If required data is missing or invalid.
        """
        # Process keyword arguments
        processed_obj, processed_data = self._process_kwargs(
            obj,
            data,
            capacitance=capacitance,
            resistance=resistance,
            weather=weather,
            power_heating=power_heating,
            power_cooling=power_cooling,
            active_heating=active_heating,
            active_cooling=active_cooling,
            ventilation=ventilation,
            temp_init=temp_init,
            temp_min=temp_min,
            temp_max=temp_max,
            gains_internal=gains_internal,
            gains_solar=gains_solar,
            area=area,
            height=height,
        )

        # Get input data
        processed_obj, processed_data = self._get_input_data(processed_obj, processed_data, ts_type)

        # Precompute auxiliary data
        processed_data[O.GAINS_SOLAR] = SolarGains().generate(processed_obj, processed_data)
        processed_data[O.GAINS_INTERNAL] = InternalGains().generate(processed_obj, processed_data)
        processed_data[O.VENTILATION] = Ventilation().generate(processed_obj, processed_data)

        # Compute temperature and energy demand
        temp_in, p_heat, p_cool = calculate_timeseries(processed_obj, processed_data)

        logger.debug(f"[HVAC R1C1] {ts_type}: max heating {p_heat.max()}, cooling {p_cool.max()}")

        return self._format_output(temp_in, p_heat, p_cool, processed_data)

    def _get_input_data(self, obj: dict, data: dict, method_type: str = Types.HVAC) -> tuple[dict, dict]:
        """Process and validate input data for HVAC calculation.

        This function extracts required and optional parameters from the input dictionaries,
        applies default values where needed, performs data validation, and prepares the
        data for HVAC calculation.

        Args:
            obj (dict): Dictionary containing building parameters such as thermal properties
                and temperature setpoints.
            data (dict): Dictionary containing input data such as weather information.
            method_type (str, optional): Method type to use for prefixing. Defaults to Types.HVAC.

        Returns:
            tuple: A tuple containing:
                - obj_out (dict): Processed object parameters with defaults applied.
                - data_out (dict): Processed data with required format for calculation.

        Notes:
            - Parameters can be specified with method-specific prefixes (e.g., "hvac:temp_min")
              which will take precedence over generic parameters (e.g., "temp_min").
        """
        obj_out = {
            O.ID: Method.get_with_backup(obj, O.ID),
            O.ACTIVE_COOLING: Method.get_with_method_backup(obj, O.ACTIVE_COOLING, method_type, DEFAULT_ACTIVE_COOLING),
            O.ACTIVE_HEATING: Method.get_with_method_backup(obj, O.ACTIVE_HEATING, method_type, DEFAULT_ACTIVE_HEATING),
            O.AREA: Method.get_with_method_backup(obj, O.AREA, method_type, Const.DEFAULT_AREA.value),
            O.GAINS_INTERNAL: Method.get_with_method_backup(obj, O.GAINS_INTERNAL, method_type),
            O.GAINS_INTERNAL_COL: Method.get_with_method_backup(obj, O.GAINS_INTERNAL_COL, method_type),
            O.GAINS_SOLAR: Method.get_with_method_backup(obj, O.GAINS_SOLAR, method_type),
            O.HEIGHT: Method.get_with_method_backup(obj, O.HEIGHT, method_type, Const.DEFAULT_HEIGHT.value),
            O.LAT: Method.get_with_method_backup(obj, O.LAT, method_type),
            O.LON: Method.get_with_method_backup(obj, O.LON, method_type),
            O.POWER_COOLING: Method.get_with_method_backup(obj, O.POWER_COOLING, method_type, DEFAULT_POWER_COOLING),
            O.POWER_HEATING: Method.get_with_method_backup(obj, O.POWER_HEATING, method_type, DEFAULT_POWER_HEATING),
            O.RESISTANCE: Method.get_with_method_backup(obj, O.RESISTANCE, method_type),
            O.CAPACITANCE: Method.get_with_method_backup(obj, O.CAPACITANCE, method_type),
            O.TEMP_INIT: Method.get_with_method_backup(obj, O.TEMP_INIT, method_type, DEFAULT_TEMP_INIT),
            O.TEMP_MAX: Method.get_with_method_backup(obj, O.TEMP_MAX, method_type, DEFAULT_TEMP_MAX),
            O.TEMP_MIN: Method.get_with_method_backup(obj, O.TEMP_MIN, method_type, DEFAULT_TEMP_MIN),
            O.VENTILATION: Method.get_with_method_backup(obj, O.VENTILATION, method_type, DEFAULT_VENTILATION),
            O.VENTILATION_COL: Method.get_with_method_backup(obj, O.VENTILATION_COL, method_type),
        }
        weather_key = Method.get_with_method_backup(obj, O.WEATHER, method_type, O.WEATHER)
        weather = Method.get_with_backup(data, weather_key)
        windows_key = Method.get_with_method_backup(obj, O.WINDOWS, method_type)
        windows = Method.get_with_backup(data, windows_key) if isinstance(windows_key, str) else None
        internal_key = Method.get_with_method_backup(obj, O.GAINS_INTERNAL, method_type)
        internal_gains = Method.get_with_backup(data, internal_key) if isinstance(internal_key, str) else None
        ventilation_key = Method.get_with_method_backup(obj, O.VENTILATION, method_type)
        ventilation = Method.get_with_backup(data, ventilation_key) if isinstance(ventilation_key, str) else None
        data_out = {
            O.WEATHER: weather,
            O.WINDOWS: windows,
            internal_key: internal_gains,
            ventilation_key: ventilation,
        }

        # Clean up
        obj_out = {k: v for k, v in obj_out.items() if v is not None}
        data_out = {k: v for k, v in data_out.items() if v is not None}

        # Safe datetime handling
        if O.WEATHER in data_out:
            weather = data_out[O.WEATHER].copy()
            weather = self._strip_weather_height(weather)
            weather[C.DATETIME] = pd.to_datetime(weather[C.DATETIME])
            weather.set_index(C.DATETIME, inplace=True, drop=False)
            data_out[O.WEATHER] = weather

        return obj_out, data_out

    @staticmethod
    def _format_output(temp_in, p_heat, p_cool, data):
        timestep = data[O.WEATHER][C.DATETIME].diff().dt.total_seconds().dropna().mode()[0]
        summary = {
            f"{Types.HEATING}{SEP}{C.DEMAND}[Wh]": int(round(p_heat.sum() * timestep / 3600)),
            f"{Types.HEATING}{SEP}{O.LOAD_MAX}[W]": int(max(p_heat)),
            f"{Types.COOLING}{SEP}{C.DEMAND}[Wh]": int(round(p_cool.sum() * timestep / 3600)),
            f"{Types.COOLING}{SEP}{O.LOAD_MAX}[W]": int(max(p_cool)),
        }

        df = pd.DataFrame(
            {
                f"{C.TEMP_IN}": temp_in,
                f"{Types.HEATING}{SEP}{C.LOAD}[W]": p_heat,
                f"{Types.COOLING}{SEP}{C.LOAD}[W]": p_cool,
            },
            index=data[O.WEATHER].index,
        )
        df.index.name = C.DATETIME

        return {"summary": summary, "timeseries": df}


def calculate_timeseries(obj: dict, data: dict) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Calculate HVAC time series using the R1C1 model.

    This function simulates the thermal behavior of a building using a simple
    one-resistance, one-capacitance (R1C1) model. It calculates the indoor temperature
    and the heating and cooling power required to maintain comfort conditions.

    Args:
        obj (dict): Dictionary containing processed building parameters such as:
            - temp_init: Initial indoor temperature in K
            - resistance: Thermal resistance in K/W
            - capacitance: Thermal capacitance in J/K
            - ventilation: Ventilation rate in W/K
            - temp_min: Minimum indoor temperature setpoint in K
            - temp_max: Maximum indoor temperature setpoint in K
            - active_cooling: Whether cooling is active (bool)
            - active_heating: Whether heating is active (bool)
            - power_cooling: Maximum cooling power in W
            - power_heating: Maximum heating power in W
        data (dict): Dictionary containing processed data such as:
            - weather: DataFrame with outdoor temperature data
            - gains_solar: Solar heat gains in W
            - gains_internal: Internal heat gains in W

    Returns:
        tuple: A tuple containing:
            - temp_in (np.ndarray): Time series of indoor temperature in K
            - p_heat (np.ndarray): Time series of heating power in W
            - p_cool (np.ndarray): Time series of cooling power in W

    Notes:
        - The function simulates the building's thermal behavior time step by time step
        - At each time step, it calculates the net heat transfer, the required heating
          and cooling power, and the resulting indoor temperature
        - The simulation accounts for thermal inertia, heat gains, and heat losses
    """
    # Get objects
    temp_init = obj[O.TEMP_INIT]
    thermal_resistance = obj[O.RESISTANCE]
    thermal_capacitance = obj[O.CAPACITANCE]
    temp_min = obj[O.TEMP_MIN]
    temp_max = obj[O.TEMP_MAX]
    active_cool = obj[O.ACTIVE_COOLING]
    active_heat = obj[O.ACTIVE_HEATING]
    power_cool_max = obj[O.POWER_COOLING]
    power_heat_max = obj[O.POWER_HEATING]
    # Get data
    solar_gains = data[O.GAINS_SOLAR].to_numpy(dtype=np.float32)
    internal_gains = data[O.GAINS_INTERNAL].to_numpy(dtype=np.float32)
    ventilation = data[O.VENTILATION].to_numpy(dtype=np.float32)
    weather = data[O.WEATHER]
    temp_air = (weather[C.TEMP_AIR]).to_numpy(dtype=np.float32) if C.TEMP_AIR in weather else None
    if temp_air is None:
        raise Exception(f"Missing temperature column: {C.TEMP_AIR}")

    timesteps = weather[C.DATETIME].diff().dt.total_seconds().dropna()
    timestep = timesteps.mode()[0]

    n_steps = len(temp_air)
    temp_in = np.zeros(n_steps, dtype=np.float64)
    temp_in[0] = temp_init
    p_heat = np.zeros(n_steps, dtype=np.float64)
    p_cool = np.zeros(n_steps, dtype=np.float64)

    # Calculate
    for t in range(1, n_steps):
        # Calculate the net heat transfer
        net_transfer = calc_net_heat_transfer(
            temp_in[t - 1], temp_air[t], thermal_resistance, ventilation[t], solar_gains[t], internal_gains[t]
        )

        # Calculate heating and cooling loads
        p_heat[t] = calc_heating_power(
            active_heat, net_transfer, temp_in[t - 1], temp_min, thermal_capacitance, power_heat_max, timestep
        )
        p_cool[t] = calc_cooling_power(
            active_cool, net_transfer, temp_in[t - 1], temp_max, thermal_capacitance, power_cool_max, timestep
        )

        # Recalculate indoor temperature
        temp_in[t] = calc_temp_in(temp_in[t - 1], net_transfer, p_heat[t], p_cool[t], thermal_capacitance, timestep)

    return temp_in, p_heat, p_cool


def calc_net_heat_transfer(temp_prev, temp_out, thermal_resistance, ventilation, solar_gains, internal_gains):
    """Calculate the net passive heat transfer between the indoor space and its environment.

    This function computes the total heat flow into or out of the building,
    considering conduction through the envelope, ventilation, solar gains, and internal gains.

    Args:
        temp_prev (float): Previous indoor temperature in °C
        temp_out (float): Outdoor temperature in °C
        thermal_resistance (float): Thermal resistance of the building envelope in K/W
        ventilation (float): Ventilation heat transfer coefficient in W/K
        solar_gains (float): Solar heat gains in W
        internal_gains (float): Internal heat gains in W

    Returns:
        float: Net heat transfer in W. Positive values indicate net heat gain,
               negative values indicate net heat loss.
    """
    conduction_loss = (temp_out - temp_prev) / thermal_resistance
    ventilation_loss = ventilation * (temp_out - temp_prev)

    return conduction_loss + ventilation_loss + solar_gains + internal_gains


def calc_heating_power(active, net_heat_transfer, temp_prev, temp_min, thermal_capacitance, heating_power, timestep):
    """Calculate required heating power to maintain minimum indoor temperature.

    This function computes the heating power needed to bring or maintain the indoor
    temperature at the minimum setpoint, considering the current temperature,
    thermal capacitance, and net heat transfer.

    Args:
        active (bool): Whether heating is active
        net_heat_transfer (float): Net heat transfer in W
        temp_prev (float): Previous indoor temperature in °C
        temp_min (float): Minimum indoor temperature setpoint in °C
        thermal_capacitance (float): Thermal capacitance of the building in J/K
        heating_power (float): Maximum available heating power in W
        timestep (float): Simulation timestep in seconds

    Returns:
        float: Required heating power in W, limited by the maximum available power.
               Returns 0 if heating is not active or not needed.
    """
    if not active:
        return 0

    required_heating_power = thermal_capacitance * (temp_min - temp_prev) / timestep - net_heat_transfer

    return _ensure_scalar(min(heating_power, max(0, required_heating_power)))


def calc_cooling_power(active, net_heat_transfer, temp_prev, temp_max, thermal_capacitance, cooling_power, timestep):
    """Calculate required cooling power to maintain maximum indoor temperature.

    This function computes the cooling power needed to bring or maintain the indoor
    temperature at the maximum setpoint, considering the current temperature,
    thermal capacitance, and net heat transfer.

    Args:
        active (bool): Whether cooling is active
        net_heat_transfer (float): Net heat transfer in W
        temp_prev (float): Previous indoor temperature in °C
        temp_max (float): Maximum indoor temperature setpoint in °C
        thermal_capacitance (float): Thermal capacitance of the building in J/K
        cooling_power (float): Maximum available cooling power in W
        timestep (float): Simulation timestep in seconds

    Returns:
        float: Required cooling power in W, limited by the maximum available power.
               Returns 0 if cooling is not active or not needed.
    """
    if not active:
        return 0

    required_cooling_power = thermal_capacitance * (temp_prev - temp_max) / timestep + net_heat_transfer

    return _ensure_scalar(min(cooling_power, max(0, required_cooling_power)))


def calc_temp_in(temp_in_prev, net_heat_transfer, heating_power, cooling_power, thermal_capacitance, timestep):
    """Calculate the new indoor temperature based on energy balance.

    This function computes the new indoor temperature by applying the energy balance
    equation, considering the previous temperature, net heat transfer, heating and
    cooling power, and the building's thermal capacitance.

    Args:
        temp_in_prev (float): Previous indoor temperature in °C
        net_heat_transfer (float): Net heat transfer in W
        heating_power (float): Applied heating power in W
        cooling_power (float): Applied cooling power in W
        thermal_capacitance (float): Thermal capacitance of the building in J/K
        timestep (float): Simulation timestep in seconds

    Returns:
        float: New indoor temperature in °C
    """

    temp_in_new = temp_in_prev + (timestep / thermal_capacitance) * (net_heat_transfer + heating_power - cooling_power)

    return _ensure_scalar(temp_in_new)


def _ensure_scalar(x):
    """Convert numpy array with single value to scalar.

    This helper function ensures that a value is returned as a scalar,
    even if it's a numpy array with a single element.

    Args:
        x: Value to convert, which may be a numpy array or a scalar

    Returns:
        Scalar value
    """
    return x.item() if isinstance(x, np.ndarray) else x
